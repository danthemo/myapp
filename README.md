# Практическое занятие 2
Ходыч Даниил Евгеньевич

ЭФМО-02-25

## Что это?
Простой HTTP-сервер, демонстрирующий базовую структуру Go-проекта. Содержит несколько эндпоинтов для проверки работы сервера.

## Пререквизиты:
1. **Go** (версии 1.21 или выше)
2. **Git**

## Как запустить:
1.  **Клонируйте репозиторий**
    ```Bash
    git clone https://github.com/danthemo/myapp.git
    ```

2.  **Перейдите в директорию проекта**
    ```Bash
    cd ./myapp
    ```

3.  **Запустите сервер командой:**
    ```bash
    go run ./cmd/myapp
    ```
4.  **Сервер будет доступен по адресу:** http://localhost:8080

## Использование:
Для браузера:
- http://localhost:8080 - выводит простой текстовый ответ
- http://localhost:8080/ping - выводит JSON-ответ со статусом и временем
- http://localhost:8080/fail - выводит JSON-ошибку

Для curl:

- Текстовый ответ
    ```Bash
    curl.exe -i https://localhost:8080
    ```
- JSON-ответ со статусом и временем
    ```Bash
    curl.exe -i http://localhost:8080/ping
    ```
- JSON-ошибка
    ```Bash
    curl.exe -i http://localhost:8080
    ```

## Структура проекта:
<СКРИНШОТ ДЕРЕВА>

## Описание файлов проекта:

### 1. `go.mod`
Файл модуля Go. Определяет имя модуля и версию Go, управляет зависимостями.

### 2. `main.go`
Точка входа в приложение. Минимальный код, который только запускает основную логику.

### 3. `app.go`
Создает HTTP-сервер, настраивает маршруты и middleware.
- Создает роутер (http.NewServeMux)
- Регистрирует обработчики для путей /, /ping, /fail
- Добавляет middleware для Request-ID
- Запускает сервер на порту 8080

### 4. `ping.go`
Обработчик эндоинта `/ping`

### 5. `logger.go`
Вспомогательная функция для логирования
- `LogRequest()` - логирование входящих запросов
- `LogError()` - ошибки
- `NewId16()` - генерация уникальных ID для запросов

### 6. `httpjson.go`
Вспомогательные функции для работы в HTTP с JSON
- `WriteJSON()` - отправка JSON ответа
- `WriteErr()` - отправка JSON ошибки

# Артефакты и их расположение:
В ходе работы были созданы следующие артефакты:

1. `main.go` -> `/cmd/myapp/` - Точка входа приложения. Согласно стандартной структуре Go-проекта, исполняемые файлы располагаются в `cmd/`, каждый в своей подпапке. Это делает очевидным, где находится вход в программу.

2. `app.go` -> `/internal/app/` - Этот файл содержит основную логику приложения: создание HTTP-сервера, роутинг, middleware. Код, который не должен импортироваться другими модулями, принадлежит `internal/`. Размещение в `internal/app/` дополнительно организует код по функциональному признаку.

3. `ping.go` -> `/internal/app/handlers/` - Обработчики HTTP-запросов - это часть логики приложения, но их логично отделить от кода инициализации сервера. Вынос в подпапку `handlers/` улучшает структуру, группируя схожие сущности, и облегчает навигацию по проекту, когда эндпоинтов станет много.

4. `logger.go` -> `/utils/` - Это вспомогательная утилита, используемая разными частями приложения. Размещение в `utils/` указывает на её вспомогательную, а не основную роль.

5. `httpjson.go` -> `/utils/` - Так же, как и логгер, это вспомогательная утилита для работы с HTTP. Её назначение - предоставлять общие функции для форматирования JSON-ответов. Размещение в той же папке `utils/` группирует весь вспомогательный код в одном месте, избегая его разброса.

# Ответы на вопросы:
1. `internal/` и `pkg/`

    `internal/` - приватный код, нельзя импортировать из других модулей. Для внутренней логики приложения.

    `pkg/` - публичный код, можно импортировать другими модулями. Для библиотек и утилит общего назначения.
    
    Когда использовать: `internal/` - для всего специфичного под проект; `pkg/` - только для кода, предназначенного для повторного использования.

2. Почему много пакетов - вредно

    Главная опасность - циклические импорты. Усложняет навигацию и понимание кода.

    Как избегать: группировать по функциональности, а не по типам; избегать мелких пакетов-утилит; использовать internal для изоляции.

3. Зачем `api/` отдельно от хендлеров

    `api/` содержит контракты: OpenAPI, protobuf, JSON-схемы.

    `internal/` содержит реализацию (как): код хендлеров.

    Причины: разделение ответственности; независимое развитие контракта и реализации.

4. Почему `src/` - плохая идея

    Создает избыточную вложенность (myproject/src/...).

    Нарушает современные стандарты сообщества (плоская структура с cmd/, internal/, pkg/ в корне).